/*Copyright (c) 2009 Ronny WelterPermission is hereby granted, free of charge, to any personobtaining a copy of this software and associated documentationfiles (the "Software"), to deal in the Software withoutrestriction, including without limitation the rights to use,copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom theSoftware is furnished to do so, subject to the followingconditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIESOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHTHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OROTHER DEALINGS IN THE SOFTWARE. */package com.nocreativity.playr{			import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.net.URLRequest;	import flash.utils.Timer;		/*	Todo list	---------	StreamPreload.COMPLETE > Get the Track length info from the ID3 tag.		*/	/**	 * Playr class by Ronny Welter. <br/>	 * Makes creating a music player easy.<br/>	 * Author: Ronny Welter <br/>	 * URL: http://Playr.noCreativity.com <br/>	 * Mail: senderHas[at]noCreativity.com <br/>	 * <br/>	 * The Playr class can be used to create easily a music player in your application/site using only a few lines of code. <br/>	 * Playr takes the heavy lifting off your hands, while you can just create cool things. Every type of application is possible starting from just playing a loop to the core of a full blown audio player.	 */	public class Playr extends EventDispatcher{					public var repeat:String = PlayrRepeat.REPEAT_NONE;		public var trackDirectory:String="";		private var singleTrack:Boolean = false;		private var _playrState:String = PlayrStates.INIT;																				private var _volume:Number=1;		private var _panning:Number=0;		private var _sound:Sound;		private var _soundChannel:SoundChannel;		private var _playlist:PlaylistManager;		private var _autoPlay:Boolean=false;		private var _pauseTimer:Number=0;		private var _trackProgressTimer:Timer = new Timer(250);		private var _mute:Boolean=false;		private var _playButton:DisplayObject;		private var _pauseButton:DisplayObject;		private var _stopButton:DisplayObject;		private var _nextButton:DisplayObject;		private var _prevButton:DisplayObject;		private var _muteButton:DisplayObject;		private var _togglePlayPauseButton:DisplayObject;		private var fadeTimer:Timer;		private var fadeBegin:Number;		private var fadeEnd:Number;		private var fadeTime:Number;		/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************			Public methods			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/  					/**		 * Creates a Playr instance. You can actually build a complete playlistsupported music player using only the constructor. Just set the all of this at once, and you're set!		 */		public function Playr(playlistURL:String='',trackDirectory:String='',autoPlay:Boolean=false,shuffle:Boolean=false,repeat:String=PlayrRepeat.REPEAT_NONE){			fadeTimer = new Timer(100);			fadeTimer.addEventListener(TimerEvent.TIMER,handleUpdate);			this.trackDirectory=trackDirectory;			this.repeat = repeat;						_playlist = new PlaylistManager(playlistURL);			this.autoPlay = autoPlay;			this.shuffle = shuffle;						_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_LOADED,playlistManagerReady);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_TRACK_OUT_OF_BOUNDS,playlistTrackOutOfBoundsErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_STREAM_ERROR, playlistStreamErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_INVALID_XML, invalidPlaylistXMLHandler);			_playlist.addEventListener(PlayrInternalEvent.TRACK_NOT_ADDED_TO_PLAYLIST, trackNotAddedToPlaylistErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.TRACK_ADDED_TO_PLAYLIST, trackAddedToPlaylistHandler);			_playlist.addEventListener(PlayrInternalEvent.CURRENT_TRACK_TO_BE_REMOVED, currentTrackToBeRemovedHandler);			_trackProgressTimer.addEventListener(TimerEvent.TIMER, notifyTrackProgress);			state = PlayrStates.WAITING;		}				/**		 * Toggles between play and pause using the play() and pause() methods.		 */		public function togglePlayPause():void{			switch(playrState){				case PlayrStates.PLAYING:					pause();					break;				case PlayrStates.PAUSED:				case PlayrStates.STOPPED:				case PlayrStates.READY:					play();					break;			}		}						/**		 * Starts playing the loaded song or the playlist.<br />		 * If a playlist has been loaded, the singleTrack property will change to false.		 * If a single track has been loaded, the singleTrack property will change to true.		 */		public function play():void{			if(_playlist.getCurrentTrack() != null){				trace("PlayrState: ",playrState);				if(playrState!=PlayrStates.PLAYING && playrState != PlayrStates.WAITING && playrState != PlayrStates.INIT){					if(_sound == null){    						var temp:Boolean = _autoPlay;						_autoPlay=false;						trace(PlayrTrack(_playlist.getCurrentTrack()));						loadTrack(_playlist.getCurrentTrack().file);						_autoPlay= temp;					}					_soundChannel = _sound.play(_pauseTimer);					_soundChannel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);					_trackProgressTimer.start();					volume = _volume;					panning = _panning;					state = PlayrStates.PLAYING;				}			}			else{				state = PlayrStates.WAITING;			}		}		/**		 * Pauses the now playing track. <br />		 */		public function pause():void{			if(_soundChannel!=null){			_pauseTimer = _soundChannel.position;			_soundChannel.stop();			_trackProgressTimer.stop();			state = PlayrStates.PAUSED;			}		}		/**		 * Stops the now playing track. <br />		 */		public function stop():void{			if(_soundChannel != null){				_pauseTimer = 0;				_soundChannel.stop();				state = PlayrStates.STOPPED;				_trackProgressTimer.stop();			}			}		/**		 * Advances the playlist to the next track. If the current track is the last track in the playlist, the playlist jumps to the first track of the playlist. <br />		 */		public function next():void{			if(_playlist.getCurrentTrack() != null)  {				stop();				_playlist.gotoNextTrack();				loadTrack(_playlist.getCurrentTrack().file);				dispatchEvent(new PlayrEvent(PlayrEvent.NEXT_TRACK));					play();			}		}		/**		 * Moves the playlist to the previous track. If the current track is the first track, the playlist jumps to the last track of the playlist. <br />		 */		public function previous():void{			stop();			_playlist.gotoPreviousTrack();			if(_playlist.getCurrentTrack() != null)  {				loadTrack(_playlist.getCurrentTrack().file);				dispatchEvent(new PlayrEvent(PlayrEvent.PREV_TRACK));					play();			}		}		/**		 * Jumps to the track of your choice in the playlist. <br />		 */		public function jumpToTrack(trackNumber:Number):void{			if(!singleTrack){					stop();					_playlist.gotoTrack(trackNumber);					loadTrack(_playlist.getCurrentTrack().file);					play();			}			else{				dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.NO_PLAYLIST_SELECTED));			}		}		/**		 * Scrobbles through the track. <br />		 */		public function scrobbleTo(target:Number):void{			if( _soundChannel != null){				_soundChannel.stop();				if(this.playrState != PlayrStates.STOPPED){					_soundChannel = _sound.play(target);					volume = _volume;					_soundChannel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);					if(this.playrState == PlayrStates.PAUSED){						pause();					}					var evt:PlayrEvent = new PlayrEvent(PlayrEvent.PLAYR_SCROBBLED);					evt.totalTime = totalTime;					evt.totalSeconds = totalSeconds;					evt.currentTime = currentTime;					evt.currentSeconds = currentSeconds;					dispatchEvent(evt);				}			}		}		/**		 * Load a XML playlist. Once loaded the internal playlist is populated with PlayrTrack objects. <br />		 */		public function loadPlaylist(playlistpath:String):void{			singleTrack = false;			_playlist.loadPlaylist(playlistpath);		}		/**		 * Loads a single track. There is no ID3 information loaded. The trackprogress/streamprogress events aren't accurate (The progress will be 0 at all times). This method is mostly designed to be used with anonymous loops. <br /> 		 * @param fileName The path to the mp3 file, you want to play.		 */		public function loadTrackFromURL(filename:String):void{			singleTrack = true;			loadTrack(filename);		}/**		 * Toggles the mute of the Playr instance. <br />		 */		public function toggleMute():void{			_mute = !_mute;			var st:SoundTransform;			if(_mute){				st = _soundChannel.soundTransform;				st.volume = 0;				_soundChannel.soundTransform = st;				dispatchEvent(new PlayrEvent(PlayrEvent.MUTED));			}			else{				st = _soundChannel.soundTransform;				st.volume = _volume;				_soundChannel.soundTransform = st;				dispatchEvent(new PlayrEvent(PlayrEvent.UNMUTED));			}		}		/**		 * Adds the play() method to a DisplayObject of your choice. <br />		 */		public function registerPlayButton(button:DisplayObject):void{			_playButton = button;			_playButton.addEventListener(MouseEvent.CLICK, handlePlayButtonClick);		}		/**		 * Adds the togglePlayPause() method to a DisplayObject of your choice. <br />		 */		public function registerTogglePlayPauseButton(button:DisplayObject):void{			_togglePlayPauseButton = button;			_togglePlayPauseButton.addEventListener(MouseEvent.CLICK, handleTogglePlayPauseButtonClick);		}		/**		 * Adds the pause() method to a DisplayObject of your choice. <br />		 */		public function registerPauseButton(button:DisplayObject):void{			_pauseButton = button;			_pauseButton.addEventListener(MouseEvent.CLICK, handlePauseButtonClick);		}		/**		 * Adds the stop() method to a DisplayObject of your choice. <br />		 */		public function registerStopButton(button:DisplayObject):void{			_stopButton = button;			_stopButton.addEventListener(MouseEvent.CLICK, handleStopButtonClick);		}		/**		 * Adds the next() method to a DisplayObject of your choice. <br />		 */		public function registerNextButton(button:DisplayObject):void{			_nextButton = button;			_nextButton.addEventListener(MouseEvent.CLICK, handleNextButtonClick);		}		/**		 * Adds the previous() method to a DisplayObject of your choice. <br />		 */		public function registerPreviousButton(button:DisplayObject):void{			_prevButton = button;			_prevButton.addEventListener(MouseEvent.CLICK, handlePreviousButtonClick);		}		/**		 * Adds the toggleMute() method to a DisplayObject of your choice. <br />		 */		public function registerMuteButton(button:DisplayObject):void{			_muteButton = button;			_muteButton.addEventListener(MouseEvent.CLICK, handleMuteButtonClick);		}		/**		 * Removes all eventlisteners from the Playr instance. <br />		 */		public function destroy():void{					if(_playButton != null){				_playButton.removeEventListener(MouseEvent.CLICK,handlePlayButtonClick);			}			if(_pauseButton != null){				_pauseButton.removeEventListener(MouseEvent.CLICK,handlePauseButtonClick);			}						if(_stopButton != null){				_stopButton.removeEventListener(MouseEvent.CLICK,handleStopButtonClick);			}			if(_muteButton != null){				_muteButton.removeEventListener(MouseEvent.CLICK,handleMuteButtonClick);			}			if(_nextButton != null){				_nextButton.removeEventListener(MouseEvent.CLICK,handleNextButtonClick);			}			if(_prevButton != null){				_prevButton.removeEventListener(MouseEvent.CLICK,handlePreviousButtonClick);			}			if(_togglePlayPauseButton != null){				_togglePlayPauseButton.removeEventListener(MouseEvent.CLICK,handleTogglePlayPauseButtonClick);			}		}		/**		 *	Fades the music out (from the current volume level to 0) 		 */		public function fadeOut(time:Number=2):void{		//	garbage.push(new Tween(this,'volume',null,this.volume,0,time,true));			fade(time,volume,0);		}		/**		 * Fades the music in (from 0 to a chosen target. If you don't give up a target volume, the fade will go from 0 to 1)		 */		public function fadeIn(time:Number=2,targetVolume:Number=1):void{			//garbage.push(new Tween(this,'volume',null,0,targetVolume,time,true));			volume=0;			fade(time,0,targetVolume);			////trace('fadeIn called');		}		/**		 * Fades the music from one volume to another over a given time frame.		 */		public function fade(time:Number,startVolume:Number,targetVolume:Number):void{			//garbage.push(new Tween(this,'volume',null,startVolume,targetVolume,time,true));			volume = startVolume;			fadeTime = time;			fadeBegin = startVolume;			fadeEnd = targetVolume;			fadeTimer.start();		}														/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************		  Public properties			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/ 				public function get playrState():String{			return _playrState;		}		private function set state(value:String):void{			_playrState = value;			var evt:PlayrEvent=new PlayrEvent(PlayrEvent.PLAYRSTATE_CHANGED);			evt.playrState = playrState;			dispatchEvent(evt);		}				/**		 * Returns the artist of the now playing track. This information is taken only from the playlist. 		 */		public function get artist():String{			try {				return _playlist.getCurrentTrack().artist;			} catch (err:Error) {}			return '';		}		/**		 * Returns the artist of the now playing track. This information is taken only from the playlist. 		 */		public function get album():String{			try {				return _playlist.getCurrentTrack().album;			} catch (err:Error) {}			return '';		}		/**		 * Returns the title of the now playing track. This information is taken only from the playlist. 		 */		public function get title():String{			try {				return _playlist.getCurrentTrack().title;			} catch (err:Error) {}			return '';		}		/**		 * Gets or sets the volume.  		 */		public function set volume(newVolume:Number):void{			if(newVolume>1){				_volume = 1;			}			else if(newVolume<0){				_volume = 0;			} else {				_volume = newVolume;			}			if(!_mute){//if not muted, automatically change the volume				if(_soundChannel != null){					var st:SoundTransform = _soundChannel.soundTransform;					st.volume = _volume;					_soundChannel.soundTransform = st;				}			}			var evt:PlayrEvent=new PlayrEvent(PlayrEvent.VOLUME_SET);			evt.volume = _volume;			dispatchEvent(evt);	//should this still be fired, even when muted?		}		public function get volume():Number{			if(_mute){				return 0;			}			else {				return _volume;			}		}		/**		 * Gets or sets the autoplay property.  		 */		public function get autoPlay():Boolean{			return _autoPlay;		}		public function set autoPlay(value:Boolean):void{			_autoPlay = value;			if(_autoPlay){				play();			}		}		/**		 * Returns the interal playlist. This is an array consisting of all PlayrTracks. 		 */		public function get playlist():PlaylistManager{			return _playlist;		}		public function set playlist(list:PlaylistManager):void{		//	//trace('New playlist found. Setting up...');			stop();			_sound = null;			_soundChannel =null;			state = PlayrStates.LOADING_PLAYLIST;			_playlist = list;			_playlist.gotoFirstTrack();			state = PlayrStates.READY;			dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));						if(autoPlay){				play();			}		}		/**		 * Gets or sets the  shuffle property of the Playr instance. Shuffle in Playr 2.0 is smart. It remembers the previous tracks. Internally there is a secondary playlist. 		 */		public function set shuffle(value:Boolean):void{			var res:Boolean = _playlist.setShuffle(value); 			if(res && playrState != PlayrStates.INIT && playrState != PlayrStates.LOADING_PLAYLIST){				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));			}			if(playrState != PlayrStates.PLAYING && res){				_playlist.gotoFirstTrack();			}		}						/**		 * Returns the total number of seconds of the now playing track. This information is taken only from the playlist. 		 */		public function get totalSeconds():Number{			return _playlist.getCurrentTrack().totalSeconds;		}		/**		 * Returns the current amount of seconds of the track that have already been played as a number (for mathematical purposes).		 */		public function get currentSeconds():Number{			if(_soundChannel!=null){				return Math.round(Math.round(_soundChannel.position/1000));			}			else{				return 0;			}		}		/**		 * Returns the current time of the track in a human readable format. Example: 2 minutes 16 seconds is '2:16'.		 */		public function get currentTime():String{			var pos:String="";			if(_soundChannel!=null){				var min:Number = (Math.round(_soundChannel.position/1000) - (Math.round(_soundChannel.position/1000)%60))/60;				var sec:Number = Math.ceil(_soundChannel.position/1000)%60;				pos = min + ':';					if(sec<10){						pos += "0";					}				pos += sec;			}			else{				pos = '0:00';			}			return pos;		}		/**		 * Returns the duration of the now playing track in a human readable format. Example: 2 minutes 16 seconds is '2:16'. This information is taken from the playlist.		 */		public function get totalTime():String{			return _playlist.getCurrentTrack().totalTime;		}		 		/**		 * Sets the panning (left and right speakers) of the music.		 */		 public function set panning(value:Number):void{		 	if(value>1){		 		_panning = 1;		 	}else if(value<-1){		 		_panning=-1		 	}else{		 		_panning = value;		 	}		 	if(_soundChannel !=null){			 	var st:SoundTransform = _soundChannel.soundTransform;			 	st.pan = _panning;			 	_soundChannel.soundTransform = st;			 }		 }		 public function get panning():Number{		 	return _panning;		 }		 public function get mute():Boolean{		 	return _mute;		 }		 public function set mute(value:Boolean):void{		 	if(_mute != value){		 		toggleMute();		 	}		 }		 		 		 		 		/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************		 Private handlers			*************************		**********************		 Private properties			*************************		**********************		 Internal functions			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/ 				private function handleUpdate(e:TimerEvent):void{						var jump:Number = (fadeEnd - fadeBegin)/(fadeTime*10);// 10 is related to the 10 steps/second. 10 steps per second because of the 100ms timer tick. Might rewrite this one day...			////trace(jump);			if(Math.abs(jump) != jump){ //volume is lowering				////trace('lowering');				if(fadeEnd > volume + jump){					fadeTimer.stop();					volume=fadeEnd;					return;				}			}			else{//volume is rising				////trace('rising');				if(fadeEnd < volume + jump){					fadeTimer.stop();					volume=fadeEnd;					return;				}			}			volume += jump;				////trace(volume);		}		 		private function handleMuteButtonClick(e:MouseEvent):void{			toggleMute();		}		private function handlePlayButtonClick(e:MouseEvent):void{			play();		}		private function handlePauseButtonClick(e:MouseEvent):void{			pause();		}		private function handleStopButtonClick(e:MouseEvent):void{			stop();		}		private function handleNextButtonClick(e:MouseEvent):void{			next();		}		private function handlePreviousButtonClick(e:MouseEvent):void{			stop();		}		private function handleTogglePlayPauseButtonClick(e:MouseEvent):void{			togglePlayPause();		}		private function playlistManagerReady(e:PlayrInternalEvent):void{			state = PlayrStates.READY;			_playlist.gotoFirstTrack();			dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_LOADED));			if(_autoPlay){				play();			}		}		public function playTrack(track:PlayrTrack):void{			loadTrack(track.file,track);		}		private function loadTrack(filename:String,track:PlayrTrack=null):void{			////trace('Loading: ',filename,' -- Singletrack: ',singleTrack);			//var debug:PlayrInternalEvent = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);			//debug.message = "here we go";			//dispatchEvent(debug);						var sp:PlayrEvent = new PlayrEvent(PlayrEvent.STREAM_PROGRESS);			sp.progress = 0;			var tp:PlayrEvent = new PlayrEvent(PlayrEvent.TRACK_PROGRESS);			tp.progress = 0;			if(!singleTrack || track != null){				//playlist driven				if(track != null){					_playlist = new PlaylistManager();					_playlist.addTrack(track);					_playlist.gotoFirstTrack();					filename = track.file; //this is kinda unnecessary, but just in case...				}								//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "playlist driven";				//dispatchEvent(debug);				if(_sound != null){					_sound.removeEventListener(ProgressEvent.PROGRESS, showStreamProgress);					_sound.removeEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				}				_sound = new Sound();				_sound.addEventListener(IOErrorEvent.IO_ERROR, ioErrorEventHandler);				_sound.load(new URLRequest(trackDirectory + filename));											dispatchEvent(sp);				dispatchEvent(tp);								_sound.addEventListener(ProgressEvent.PROGRESS, showStreamProgress);				_sound.addEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				dispatchEvent(new PlayrEvent(PlayrEvent.SONGINFO));					//I still wonder if this is the right place to fire this event. Even though everything will be fine, even when an IOError occurs...				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;									//}			}			else{				////trace('ello');				//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "singletrack driven";				//dispatchEvent(debug);				var track:PlayrTrack = new PlayrTrack();				track.file = filename;								_playlist = new PlaylistManager();				_playlist.addTrack(track);				_playlist.gotoFirstTrack();								//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "Playlist ready";				//dispatchEvent(debug);									if(_sound != null){					_sound.removeEventListener(ProgressEvent.PROGRESS, showStreamProgress);					_sound.removeEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				}								_sound = new Sound();				_sound.load(new URLRequest(trackDirectory + filename));											dispatchEvent(sp);				dispatchEvent(tp);								_sound.addEventListener(ProgressEvent.PROGRESS, showStreamProgress);				_sound.addEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);								_sound.addEventListener(Event.ID3, updateSingleTrackID3Info);				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;				//}			}			if(autoPlay){				play();			}		}		private function updateSingleTrackID3Info(e:Event):void{			_playlist.getCurrentTrack().artist = Sound(e.target).id3.artist;			_playlist.getCurrentTrack().album = Sound(e.target).id3.album;			_playlist.getCurrentTrack().title = Sound(e.target).id3.songName;			dispatchEvent(new PlayrEvent(PlayrEvent.SONGINFO));			}		private function soundIOErrorHandler(e:IOErrorEvent):void{			stop();			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.SOUND_STREAM_ERROR));			next();					}		private function invalidPlaylistXMLHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.PLAYLIST_INVALID_XML));		}		private function showStreamProgress(e:ProgressEvent):void{			var pe:PlayrEvent = new PlayrEvent(PlayrEvent.STREAM_PROGRESS);			pe.progress = e.bytesLoaded/e.bytesTotal;			dispatchEvent(pe);		}		private function notifyTrackProgress(e:TimerEvent):void{			if(_soundChannel != null && _playlist.getCurrentTrack() != null){				var pe:PlayrEvent = new PlayrEvent(PlayrEvent.TRACK_PROGRESS);				if(!singleTrack){					var total:Number = Math.ceil(this._sound.length/1000);					var pos:Number = Math.ceil(_soundChannel.position/1000);					_playlist.getCurrentTrack().totalSeconds = (_playlist.getCurrentTrack().totalSeconds != total) ? total : _playlist.getCurrentTrack().totalSeconds;					pe.progress = pos/_playlist.getCurrentTrack().totalSeconds;					pe.totalSeconds = _playlist.getCurrentTrack().totalSeconds;					trace('Playr.notifyTrackProgress().1 --> _playlist.getCurrentTrack().totalSeconds='+_playlist.getCurrentTrack().totalSeconds+', total='+total+', pos='+pos+', pe.progress='+pe.progress);				}				dispatchEvent(pe);			}		}		private function playlistTrackOutOfBoundsErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.TRACK_OUT_OF_BOUNDS));		}		private function playlistStreamErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.PLAYLIST_STREAM_ERROR));		}		private function trackNotAddedToPlaylistErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.TRACK_NOT_ADDED_TO_PLAYLIST));		}		private function trackAddedToPlaylistHandler(e:PlayrInternalEvent):void{			if(_playlist.totalTracks ==1){				_playlist.gotoFirstTrack();				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;				//}				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_LOADED));			}			else{				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));			}			if(_playlist.toArray().length ==0){				_playlist.gotoFirstTrack();	//logica?			}			if(autoPlay){				play();			}		}		private function ioErrorEventHandler(e:IOErrorEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.IO_ERROR));		}		private function currentTrackToBeRemovedHandler(e:PlayrInternalEvent):void{			stop();			_sound =null;			_soundChannel=null;			_playlist.gotoNextTrack();		}		private	function soundCompleteHandler(e:Event):void{			dispatchEvent(new PlayrEvent(PlayrEvent.TRACK_COMPLETE));			//			if(_playlist.totalTracks == _playlist.currentTrackNumber){ //end of playlist//				if(repeat == PlayrRepeat.REPEAT_ALL){//					dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_END_REACHED));//					next();//					play();//				}//				else if(repeat == PlayrRepeat.REPEAT_NONE){//					stop();//				}//			}//			else{//				if(repeat == PlayrRepeat.REPEAT_SINGLE){	//end of track!//					stop();//					play();//				}//				else{//					next();//					play();//				}//			}		}	} }