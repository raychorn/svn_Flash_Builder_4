/** * Original SmoothSpectrum AS component was developed by Thibault Imbert.  *  * See http://www.bytearray.org/?p=9 for the original example and source code. * * Adopted and converted to UIComponent by Taras Novak (www.randomfractals.com) **/package org.bytearray.spectrums{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Shape;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.BlurFilter;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.media.SoundMixer;	import flash.utils.ByteArray;		import mx.core.UIComponent;	public class SmoothSpectrum extends UIComponent	{    public static var MIN_WIDTH:Number = 320;    public static var MIN_HEIGHT:Number = 160;				[Bindable]		public var amplitude:int = 240;				private var soundBytes:ByteArray;		private var soundPoints:Array;		private var midPoints:Array;		private var colors:Array;		private var ratios:Array;		private var alphas:Array;		private var matrix:Matrix;		private var blendArray:Array;		private var blendStyle:String;				private var i:int;		private var offset:Number;			private var soundPointCount:int;		private var curveLength:int;		private var midPointX:Number;		private var midPointY:Number;		private var mouseDown:Boolean;				// graphic members		private var curveShape:Shape;		private var bitmapData:BitmapData;		private var bitmap:Bitmap;		private var destinationPoint:Point;		private var blurFilter:BlurFilter;		private var colorTransform:ColorTransform;		private var displaceMatrix:Matrix;						private var transparent:Boolean = true;						public function SmoothSpectrum()		{									this.width = 420;			this.height = 400;												// our bitmap screen, where the curves are drawn			bitmapData = new BitmapData(this.width + 100, this.height, this.transparent, 0);						// default blendMode			blendStyle = 'normal';						// using multiple of 2 increases performance by 40%			blurFilter = new BlurFilter(2, 2, 2);						// colorTransformation			colorTransform = new ColorTransform();						colorTransform.color = Math.random()*0xFFFFFF;												// byteArray to hold frequencies			soundBytes = new ByteArray();						//rotate it				displaceMatrix = new Matrix();						blendArray = ['layer', 'multiply', 'screen', 'lighten', 'darken',						  'difference', 'add', 'subtract', 'invert', 'alpha', 'erase', 						  'overlay', 'hardlight'];						// points holder			soundPoints = new Array();						// midpoints holder			midPoints = new Array();									// the curve to draw the spectrum			curveShape = new Shape();						// the point			destinationPoint = new Point(0, 0);						// setup color gradients			colors = [0x990000, 0x00FF00];			alphas = [100, 100];			ratios = [80, 255];			matrix = new Matrix();			matrix.createGradientBox(850, 1, 0, 0, 0);						//addEventListener(Event.ADDED_TO_STAGE, onAdded);					}				//-------- UIComponent Methods -----------------------				override protected function measure():void 		{    	super.measure();        	      this.measuredWidth = 420;      this.measuredMinWidth = SmoothSpectrum.MIN_WIDTH;            this.measuredHeight = 300;      this.measuredMinHeight = SmoothSpectrum.MIN_HEIGHT;    }				 		override protected function createChildren():void		{									super.createChildren();						// add wave bitmap to the displayList			bitmap = new Bitmap(bitmapData);			addChild(bitmap);									// the curve to draw the spectrum			curveShape = new Shape();						addEventListener(Event.ADDED_TO_STAGE, onAdded);								}								override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void 		{						super.updateDisplayList(unscaledWidth, unscaledHeight);						if(isNaN(unscaledWidth) || isNaN(unscaledHeight)) 			{				return;			}						resizeBitmaps(unscaledWidth, unscaledHeight);		}								//-------- Rendering ----------------------------						private function resizeBitmaps(newWidth:uint, newHeight:uint):void		{			var tempBitmapData:BitmapData;						if (newWidth != bitmapData.width || newHeight != bitmapData.height)			{				// create new bitmap				tempBitmapData = bitmapData;				bitmapData = new BitmapData(newWidth, newHeight, this.transparent, 0x000000);				tempBitmapData.dispose();				bitmap.bitmapData = bitmapData;				bitmap.width = newWidth;				bitmap.height = newHeight;			}		}				private function updatePoints(pEvt:Event):void		{			if (!enabled)			{				// don't update				return;			}						// clear each frame			curveShape.graphics.clear();						curveShape.graphics.lineStyle(.01);						// apply gradient to the line			curveShape.graphics.lineGradientStyle('linear', colors, alphas, ratios, matrix, 'pad', 'linearRGB', 0.1);						// generate the ByteArray			SoundMixer.computeSpectrum(soundBytes, false); // mouseDown);						i = 32; //16;						while ( --i > -1 )			{															// change the position of the pointer				soundBytes.position = i * 64; // 128;								// get frequency				offset = soundBytes.readFloat() * amplitude;								// push each points 				// x = int(60 + ( 40 * i )				soundPoints[i] = new Point( ( 40 * i ) - 60, int(bitmap.height/2 + 60 + (-offset)));							}						soundPointCount = soundPoints.length;						// now generate a mid-point array			// to make those mid-points the curve anchor points			for (var j:int = 1; j< soundPointCount; j++)			{								midPointX = ( soundPoints[j].x + soundPoints[int(j-1)].x )/2				midPointY = ( soundPoints[j].y + soundPoints[int(j-1)].y )/2								midPoints[int(j-1)] = new Point (int(midPointX), int(midPointY));			}						// make the curve start at the first mid-point location			curveShape.graphics.moveTo(midPoints[0].x, midPoints[0].y);						curveLength = soundPointCount-1;						// then draw the curve			for (var k:int = 1; k< curveLength; k++ )			{				curveShape.graphics.curveTo(soundPoints[k].x, soundPoints[k].y, midPoints[k].x, midPoints[k].y);			}			// scroll the bitmap			//bitmapData.scroll(1, 0);			// draw curve vectors on the BitmapData			bitmapData.draw(curveShape, null, null, "add");						bitmapData.applyFilter(bitmapData, bitmapData.rect, destinationPoint, blurFilter);					}				//---------- Event Handlers ---------------------										private function onAdded(event:Event):void 		{						addEventListener(Event.ENTER_FRAME, updatePoints);									addEventListener(Event.REMOVED, onRemoved);						stage.addEventListener(MouseEvent.MOUSE_DOWN, onClick);			stage.addEventListener(MouseEvent.MOUSE_MOVE, updateBlend);											}					public function onRemoved(event:Event):void 		{						bitmapData.dispose();						removeEventListener(Event.ENTER_FRAME, updatePoints);						stage.removeEventListener(MouseEvent.MOUSE_DOWN, onClick);			stage.removeEventListener(MouseEvent.MOUSE_MOVE, updateBlend);																	}				private function onClick(event:MouseEvent):void		{						updateBlend(event);			mouseDown = !mouseDown					}												private function updateBlend(event:MouseEvent):void		{			blendStyle = blendArray[ Math.floor ( Math.random()* blendArray.length ) ];						colors = [Math.random()*0xFFFFFF, Math.random()*0xFFFFFF];								}	}}